# NB: this file and its syntax is entirely aspirational.

Data.Function : Module
{

id
: { A : Type } -> (x : A) -> A
{ x }
# NB: equivalently: id : {A : Type} -> A -> A {x -> x}

const
: { A, B : Type } -> (x : A) -> (_ : B) -> A
{ x }
# NB: equivalently: const : { A, B : Type } -> (x : A) -> B -> A { _ -> x }
# NB: equivalently: const : { A, B : Type } -> A -> B -> A { x _ -> x }

flip
: { A, B, C : Type } -> (f : A -> B -> C) -> (B -> A -> C) # NB: this rightmost set of parens is technically redundant, but useful to understand what the function does
{ b a -> f a b } # note that we didn’t bind the latter operands in the type so we’re binding (pattern matching on) them both here instead


# commented out because products aren’t in the kernel theory any more
# curry
# : { A, B, C : Type } -> (f : (A, B) -> C) -> (x : A) -> (y : B) -> C
# { f (x, y) }

# uncurry
# : { A, B, C : Type } -> (f : A -> B -> C) -> (A, B) -> C
# { (x, y) -> f x y } # NB: you can’t bind individual fields of a type in the signature, so we have to pattern match here
# NB: equivalently: uncurry : { A, B, C : Type } -> (f : A -> B -> C) -> (x : (A, B)) -> C { f (fst x) (snd x) } # assuming standard definitions of these projections

# would be nice to support pattern matching for a single case in the sig, tho…
# uncurry
# : { A, B, C : Type } -> (f : A -> B -> C) -> (x : A, y : B) -> C
# { f x y }

# fixme: do we want to support mixfix syntax?
# fixme: how do we want to specify fixity?
_ << _
: { A, B, C : Type } -> (f : B -> C) -> (g : A -> B) -> (A -> C)
{ a -> f (g a) }
# NB: equivalently: (<<) : { A, B, C : Type } -> (f : B -> C) -> (g : A -> B) -> (a : A) -> C { f (g a) }

_ >> _
: { A, B, C : Type } -> (g : A -> B) -> (f : B -> C) -> (A -> C)
{ a -> f (g a) }
# NB: equivalently: (>>) : { A, B, C : Type } -> (g : A -> B) -> (f : B -> C) -> (a : A) -> C { f (g a) }


# fixme: I honestly can’t tell if these are backwards relative to composition or not
_ <| _
: { A, B : Type } -> (f : A -> B) -> (a : A) -> B
{ f a }
# NB: equivalently: { A, B : Type } -> (f : A -> B) -> A -> B { f }
# NB: equivalently: { A, B : Type } -> (A -> B) -> A -> B { id }

_ |> _
: { A, B : Type } -> (a : A) -> (f : A -> B) -> B
{ f a }


case
: { A, B : Type } -> A -> (A -> B) -> B
{ (_ |> _) }

# desugars to:
# case
# : { A : Base.Type.Type } -> { B : Base.Type.Type } -> A -> (A -> B) -> B
# { (_ Base.Function.|> _) }

}
